##### 1. 什么是闭包？

- 我的理解：其实就是函数包含函数，并且内部函数能够访问到其外部函数的作用域，以及外部函数返回内部函数的引用，这样的组合就是闭包。


##### 2. 闭包有哪些使用场景？

闭包可以用于以下场景（摘自 chatgpt）：

1. 将函数作为另一个函数的参数传递，例如使用 sort 函数对数组进行排序时，可以自定义排序规则。
2. 保存函数的状态，例如计数器函数，每次调用函数都能够自增并返回正确的计数。这个计数器变量会在函数中被创建，并且由于闭包的存在，它会一直被保存在内存中。
3. 模拟私有变量，将函数返回一个内部函数，以保护内部状态不被外部直接访问或者修改。
4. 缓存中间结果，例如在递归函数中，需要反复计算一些中间结果，可以将这些结果缓存在函数内部的一个变量中，减少重复计算。
5. 使用闭包可以实现类似于面向对象的功能，例如在 JavaScript 中，可以使用闭包来实现类和继承。

场景一举例：有一个数组，其中包含了多个对象，每个对象都有一个名字属性，我们要按照名字属性对这些对象进行排序。可以使用 sort 函数，并传递一个自定义的比较函数作为参数，比较函数可以访问对象的名字属性，从而进行对象之间的比较。具体的代码如下所示：

```js
var persons = [
  { name: "Alice", age: 28 },
  { name: "Bob", age: 24 },
  { name: "Charlie", age: 32 },
];

persons.sort(function (a, b) {
  if (a.name < b.name) {
    return -1;
  }
  if (a.name > b.name) {
    return 1;
  }
  return 0;
});
```

这里的比较函数就是一个闭包，它可以访问外部函数的变量 persons，以及对象中的 name 属性。通过这个闭包，我们可以将 sort 函数用于不同的对象数组，只需要修改比较函数即可。

##### 3. 介绍一些数组的常用方法：

数组在 JavaScript 中是一种非常常用的数据结构，下面给你介绍几个常用的数组数据处理方法（摘自 chatgpt）：

1. `push()`方法：在数组的末尾添加元素。

```js
const arr = [1, 2, 3];
arr.push(4);
console.log(arr); // [1, 2, 3, 4]
```

2. `pop()`方法：从数组的末尾删除元素。

```js
const arr = [1, 2, 3];
arr.pop();
console.log(arr); // [1, 2]
```

3. `shift()`方法：从数组的开头删除元素。

```js
const arr = [1, 2, 3];
arr.shift();
console.log(arr); // [2, 3]
```

4. `unshift()`方法：在数组的开头添加元素。

```js
const arr = [1, 2, 3];
arr.unshift(0);
console.log(arr); // [0, 1, 2, 3]
```

5. `slice()`方法：返回一个新的数组，包含原始数组中指定的开始到结束位置之间的片段。

```js
const arr = [1, 2, 3, 4, 5];
const newArr = arr.slice(1, 4);
console.log(newArr); // [2, 3, 4]
```

6. `splice()`方法：从数组中添加或删除元素。

```js
const arr = [1, 2, 3, 4, 5];
arr.splice(2, 1); // 从第2个元素开始，删除一个元素
console.log(arr); // [1, 2, 4, 5]

arr.splice(2, 0, 3); // 从第2个元素开始，删除0个元素，添加一个新元素3
console.log(arr); // [1, 2, 3, 4, 5]
```

7. `map()`方法：返回一个新数组，其中每个元素都是原始数组元素调用函数处理后的结果。

```js
const arr = [1, 2, 3];
const newArr = arr.map((x) => x * 2);
console.log(newArr); // [2, 4, 6]
```

8. `filter()`方法：返回一个新数组，其中包含所有通过函数筛选的原始数组元素。

```js
const arr = [1, 2, 3, 4, 5];
const newArr = arr.filter((x) => x % 2 === 0);
console.log(newArr); // [2, 4]
```

##### 4. 什么是浅拷贝与深拷贝？有啥区别？

在 JavaScript 中，对象和数组是可以被直接赋值的引用类型，这意味着对原始对象或数组所做的更改将会影响到所有被赋值的变量。解决这个问题的方法是在操作之前进行对象或数组的拷贝，从而获得一个新的数据副本，这就是浅拷贝和深拷贝的基本概念。

浅拷贝只会复制对象或数组的引用，新复制的变量会与原来的变量共享同一个对象或数组。浅拷贝通常可以通过 Object.assign() 或 Spread 运算符（...）轻松实现。例如：

```js
const obj = { a: 1, b: 2 };
const shallowCopyObj = { ...obj };
const shallowCopyArr = [...arr];
```

但是，当对象或数组中包含了嵌套的对象或数组时，浅拷贝的方式就不能满足要求了，因为只会复制一层引用，内部的对象和数组依然会被多个变量共享。这就需要深拷贝来解决这个问题。

深拷贝会复制整个对象或数组，包括其所有嵌套的对象和数组，并且所有复制出来的变量彼此独立，互不影响。具体实现可以通过递归遍历对象或数组，对每个嵌套的对象或数组进行深层拷贝。以下是一个简单的深拷贝函数实现：

```js
function deepClone(obj) {
  let result;
  if (Array.isArray(obj)) {
    result = [];
    obj.forEach((item, index) => {
      result[index] = deepClone(item);
    });
  } else if (typeof obj === "object") {
    result = {};
    Object.keys(obj).forEach((key) => {
      result[key] = deepClone(obj[key]);
    });
  } else {
    return obj;
  }
  return result;
}
```

需要注意的是，深拷贝函数也有自己的限制。例如，递归的层数过多时可能会导致栈溢出。这个时候需要使用其他方法来实现（摘自 chatgpt）。

##### 5. 什么是回调函数？

- 回调函数（Callback Function）是指在某个函数执行完毕后，将另一个函数作为参数传入并在该函数执行完毕后被调用的函数。换句话说，回调函数是一种通过参数传递的函数，用于在另一个函数执行完毕后被调用。回调函数通常用于异步编程中，比如事件处理、定时器、网络请求等场景下的回调操作。

回调函数的特点在于：

1. 函数作为参数传递：回调函数是通过函数参数的形式传递的，可以实现函数的动态调用。
2. 异步执行：回调函数通常用于异步编程中，可以在异步操作完成后被调用。
3. 作为处理函数：回调函数通常被作为处理函数传递，用于处理异步操作的结果。
   回调函数在 JavaScript 中被广泛使用，比如事件处理函数、定时器回调函数、Ajax 请求回调函数等。回调函数的使用可以实现异步编程，避免了阻塞线程的问题，提高了程序的性能。同时，回调函数也可以实现函数的复用和功能的拓展。

##### 6.给你一个请求URL地址，怎么去获取该地址的参数名和参数值 ？

要获取URL地址的参数名和参数值，‌可以通过以下步骤进行：‌

1. **获取URL的搜索部分**：‌使用`window.location.search`可以获取URL的搜索部分（‌即问号`?`后面的部分）‌，‌这部分包含了所有的参数。‌例如，‌对于URL`https://www.example.com?param1=value1&param2=value2`，‌`window.location.search`将返回`?param1=value1&param2=value2`。‌
2. **解析搜索参数**：‌可以使用`URLSearchParams`构造函数来解析搜索部分，‌并将其转换为一个可以方便操作的对象。‌这个对象提供了`get()`方法，‌可以用来获取指定参数的值。‌
3. **获取参数名和参数值**：‌通过遍历需要的参数名，‌并使用`URLSearchParams`对象的`get()`方法，‌可以获取到对应的参数值。‌如果参数不存在，‌可以使用默认值来避免`undefined`。‌

例如，‌可以通过以下函数封装来实现这一过程：‌

```js
function getUrlParams(url, options) {
  const search = url.split('?').slice(-1); // 获取搜索部分
  const params = new URLSearchParams(search); // 解析搜索参数
  const result = {}; // 用于存储结果的对象
  Object.keys(options).forEach(key => {
    result[key] = params.get(key) || defaultValue; // 获取指定参数的值，如果不存在则使用默认值
  });
  return result; // 返回包含参数名和参数值的结果对象
}
```

使用这个函数，‌可以方便地获取URL中的参数，‌例如：‌

```js
const { param1, param2 } = getUrlParams(window.location, { param1: '默认值1', param2: '默认值2' });
console.log(param1, param2); // 如果param1和param2存在于URL中，将输出它们的值，否则输出默认值。
```

这样，‌就可以根据需要获取URL中的参数名和参数值了。‌

##### 7. js 的数据类型有哪些 ? 基本数据类型与引用数据类型的区别？

- **基本数据类型**包括：‌
  1. **Number**：‌表示整数或浮点数，‌有特殊值如-Infinity、‌Infinity、‌NaN。‌
  2. **String**：‌一串表示文本的字符序列。‌
  3. **Undefined**：‌只有一个值`undefined`。‌
  4. **Null**：‌只有一个值`null`，‌表示空指针对象。‌
  5. **Boolean**：‌包含两个值`true`和`false`。‌
  6. **Symbol**：‌一种唯一且不可变的数据类型，‌用于创建独一无二的值。‌
  7. **BigInt**：‌表示大整数，‌必须添加后缀`n`。‌
- **引用数据类型**包括：‌
  1. **Object**：‌包含常规对象、‌数组、‌内置对象等。‌

**基本数据类型与引用数据类型的区别在于它们的存储方式和可变性**：‌

- **基本数据类型**存储在栈内存中，‌其大小是固定的，‌直接按值存放，‌因此是直接访问的。‌例如，‌当你将一个基本数据类型的变量赋值给另一个变量时，‌实际上是创建了一个新的值的副本。‌因此，‌对一个变量的修改不会影响到另一个变量。‌
- **引用数据类型**存储在堆内存中，‌其大小是可变的。‌变量实际上保存的是在栈内存中的一个指针，‌这个指针指向堆内存中的一个对象。‌因此，‌当你将一个引用数据类型的变量赋值给另一个变量时，‌实际上是复制了引用地址，‌而不是对象本身。‌这意味着，‌对一个变量的修改可能会影响到另一个变量，‌因为它们可能指向同一个对象。‌

这种区别使得基本数据类型和引用数据类型在 JavaScript 中的行为和操作有所不同，‌理解这一点对于编写高效的JavaScript代码至关重要。
